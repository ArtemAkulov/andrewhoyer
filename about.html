---
layout: default
permalink: /about/
---
<style>
body {
    background: #eee;
}

canvas {
    background: transparent;
    margin: 0 40px 40px;
}

#about-text {
    display: none;
}
</style>

<p id="about-text">I am a software engineer in my mid-twenties living it up in
sometimes sunny San Francisco. I enjoy walking, eating and
occasionally coding. I do not enjoy angry music, pickles or
the word cyberspace. I sometimes miss Canada.</p>

<canvas height="400px" width="820px"></canvas>

<script type="text/javascript">

// Implement a super simple non standard version of bind, if not already there.
// I'm looking at you Safari...
if (!Function.prototype.bind){
    Function.prototype.bind = function (bind){
        var self = this;
        return function(){
            return self.apply(bind, arguments);
        };
    };
}

// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik MÃ¶ller
// fixes from Paul Irish and Tino Zijdel

(function() {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']
                                   || window[vendors[x]+'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); },
              timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
}());

var Letter = function(options){
    this.character_ = options.character;

    // original, previous, and current position.
    this.ox_ = this.px = this.x = options.x;
    this.oy_ = this.py = this.y = options.y;

    this.maxX_ = options.maxX;
    this.maxY_ = options.maxY;

    this.simulation_ = options.simulation;

    this.rotation_ = 0;
};

Letter.prototype = {

    BORDER_THRESHOLD_: 5,

    BOUNCE_: 1,

    SNAP_THRESHOLD_: 0.075,

    ATTRACTION_: 0.01,

    DIRECTION_DAMPNING_: 2,

    update: function(context){
        // Calculate the new position.
        var newX = this.updateValue_(this.x, this.px);
        var newY = this.updateValue_(this.y, this.py);

        // Move the current position into previous position before setting the new position.
        this.px = this.x;
        this.py = this.y;
        this.x = newX;
        this.y = newY;

        this.detectCollisions_(newX, newY);

        // Hack: Not quite sure how this is still happening even with the bounce I add.
        if (this.x < this.BORDER_THRESHOLD_ || this.y < this.BORDER_THRESHOLD_){
            this.px = this.x = this.ox_;
            this.py = this.y = this.oy_;
        }

        this.updateRotation_();

        this.applyAttraction_();

        // Draw the line first.
        context.beginPath();
        context.moveTo(this.ox_, this.oy_);
        context.lineTo(this.x, this.y);
        context.stroke();

        // Then draw the actual character.
        context.save();
        context.translate(this.x, this.y);
        context.rotate(this.rotation_);
        context.fillText(this.character_, 0, 0);
        context.restore();
    },

    updateValue_: function(current, previous){
        return (current * 1.99) - (previous * 0.99);
    },

    detectCollisions_: function(newX, newY){
        // Adjust to container bounds horizontally.
        var collisionType;
        if (this.x < this.BORDER_THRESHOLD_ || this.x > this.maxX_ - this.BORDER_THRESHOLD_){
            collisionType = (this.x < 5) ? 'left' : 'right';
            this.simulation_.addCollision(this.x, this.y, collisionType);

            this.x = this.px;
            this.px = newX + (collisionType == 'left' ? -this.BOUNCE_ : this.BOUNCE_);
        }

        // Adjust to container bounds vertically.
        if (this.y < this.BORDER_THRESHOLD_ || this.y > this.maxY_ - this.BORDER_THRESHOLD_){
            collisionType = (this.y < 5) ? 'top' : 'bottom';
            this.simulation_.addCollision(this.x, this.y, collisionType);

            this.y = this.py;
            this.py = newY + (collisionType == 'top' ? -this.BOUNCE_ : this.BOUNCE_);
        }
    },

    updateRotation_: function(){
        var dx = this.x - this.ox_;
        var dy = this.y - this.oy_;

        if (this.isNearOrigin_(dx, dy)){
            this.rotation_ = 0;
        } else {
            this.rotation_ = Math.atan2(dy, dx);
        }
    },

    applyAttraction_: function(){
        var dx = this.x - this.ox_;
        var dy = this.y - this.oy_;

        // Move the actual particle closer to its original point.
        if (this.isNearOrigin_(dx, dy)){
            this.px = this.x = this.ox_;
            this.py = this.y = this.oy_;
        } else {
            this.x -= Math.cos(this.rotation_) * this.ATTRACTION_;
            this.y -= Math.sin(this.rotation_) * this.ATTRACTION_ * Math.max(2, Math.abs(dy));

            if (dx < 0) this.x += this.ATTRACTION_ * Math.max(3, dx);
        }
    },

    isNearOrigin_: function(dx, dy){
        return (Math.abs(dx) < this.SNAP_THRESHOLD_) &&
            (Math.abs(dy) < this.SNAP_THRESHOLD_) &&
            (Math.abs(this.x - this.px) < this.SNAP_THRESHOLD_) &&
            (Math.abs(this.y - this.py) < this.SNAP_THRESHOLD_);
    }
};

var Collision = function(x, y, type){
    this.x = x;
    this.y = y;

    if (type == 'top' || type == 'bottom'){
        this.w = 10;
        this.h = 1;
        this.x -= this.w / 2;
    } else {
        this.w = 1;
        this.h = 10;
        this.y -= this.h / 2;
    }

    this.age_ = 0;
    this.lifetime_ = 500;
    this.opacity_ = 0.1;
};

Collision.prototype = {
    update: function(context, dt){
        this.age_ += dt;
        context.fillStyle = 'rgba(0, 0, 0, ' + this.currentOpacity_() + ')';
        context.fillRect(this.x, this.y, this.w, this.h);
        return (this.age_ < this.lifetime_);
    },

    currentOpacity_: function(){
        return this.opacity_ * (1 - (this.age_ / this.lifetime_));
    }
};

var Simulation = function(){
    this.canvas_ = document.querySelector('canvas');
    this.context_ = this.canvas_.getContext('2d');

    this.context_.font = 'normal 12px lucida grande, lucida, sans-serif';
    this.context_.strokeStyle = 'rgba(0, 0, 0, 0.1)';
    this.context_.textBaseline = 'middle';
    this.context_.lineWidth = 0.5;

    this.collisions_ = [];

    this.boundStep_ = this.step_.bind(this);

    this.initializeLetters_();
    this.start_();

    this.canvas_.addEventListener('mousemove', this.cursorMoved_.bind(this), false);
    this.canvas_.addEventListener('touchmove', this.cursorMoved_.bind(this), false);
};

Simulation.prototype = {

    LINE_HEIGHT: 15,

    addCollision: function(x, y, type){
        if (type == 'top') y = 0;
        if (type == 'right') x = this.canvas_.width - 2;
        if (type == 'bottom') y = this.canvas_.height - 2;
        if (type == 'left') x = 0;

        this.collisions_.push(new Collision(x, y, type));
    },

    initializeLetters_: function(){
        var text = document.getElementById('about-text').textContent;
        var tempLetters = [];
        var x = 0;
        var y = 0;
        var textWidth = 0;
        var textHeight = 0;

        text.split('').forEach(function(letter){
            if (letter == '\n'){
                y += this.LINE_HEIGHT;
                x = 0;
                return;
            }

            if (letter !== ' '){
                tempLetters.push({
                    x: x,
                    y: y,
                    c: letter
                });
            }

            x += this.context_.measureText(letter).width;

            textWidth = Math.max(x, textWidth);
            textHeight = Math.max(y + this.LINE_HEIGHT, textHeight);
        }, this);

        // Create and center the text in the middle of the canvas.
        var offsetX = (this.canvas_.width - textWidth) / 2;
        var offsetY = (this.canvas_.height - textHeight) / 2;
        this.letters_ = tempLetters.map(function(letter){
            letter = new Letter({
                character: letter.c,
                x: letter.x + offsetX,
                y: letter.y + offsetY,
                maxX: this.canvas_.width,
                maxY: this.canvas_.height,
                simulation: this
            });
            return letter;
        }, this);

        // Choose a random letter to animate.
        var randomLetter = this.letters_[Math.round(Math.random() * (this.letters_.length - 1))];
        randomLetter.x -= 10;
        randomLetter.y -= 10;
        randomLetter.px -= 10.5;
        randomLetter.py -= 10;
    },

    cursorMoved_: function(evt){
        // Handle touch events.
        if (evt.touches && evt.touches.length){
            evt = evt.touches[0];
        }

        var x = evt.pageX - this.canvas_.offsetLeft;
        var y = evt.pageY - this.canvas_.offsetTop;
        var dx, dy, distance, letter;

        for (var i = 0, l = this.letters_.length; i < l; i++){
            letter = this.letters_[i];
            dx = letter.x - x;
            dy = letter.y - y;
            distance = (dx * dx) + (dy * dy);

            if (distance < 2500){
                letter.x += dx / 100;
                letter.y += dy / 100;
            }
        }
    },

    start_: function(){
        this.previousTime_ = +new Date();
        requestAnimationFrame(this.boundStep_);
    },

    step_: function(currentTime){
        var dt = currentTime - this.previousTime_;
        
        if (dt > 20){
            var context = this.context_;
            var letters = this.letters_;
            var collisions = this.collisions_;
            var activeCollisions = [];
            var i, l;

            context.clearRect(0, 0, this.canvas_.width, this.canvas_.height);

            context.fillStyle = '#464646';

            for (i = 0, l = letters.length; i < l; i++){
                letters[i].update(context);
            }

            for (i = 0, l = collisions.length; i < l; i++){
                if (collisions[i].update(context, dt)){
                    activeCollisions.push(collisions[i]);
                }
            }
            this.collisions_ = activeCollisions;

            this.previousTime_ = currentTime;
        }

        requestAnimationFrame(this.boundStep_);
    }
};

// Start the page.
new Simulation();
</script>